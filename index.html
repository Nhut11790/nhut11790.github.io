<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="format-detection" content="telephone=no" />
  <title>ƒê√†n Piano</title>
  <style>
    :root{
      --white-key-height:150px;
      --black-key-height:90px;
      --white-key-bg: linear-gradient(to bottom, #fff 0%, #ececec 100%);
      --white-key-border: 2px solid #222;
      --black-key-bg: linear-gradient(to bottom, #444 0%, #091a21 100%);
      --active-green-w: linear-gradient(137deg, #2ecc71 0%, #27ae60 100%);
      --active-green-b: linear-gradient(137deg, #1fa86a 0%, #13914f 100%);
      --bottom-gap: 12px; /* kho·∫£ng tr·ªëng d∆∞·ªõi c√πng khi piano k√©o xu·ªëng */
    }

    html, body {
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: auto;
      background: #ffffff; /* b·ªè n·ªÅn t√≠m, chuy·ªÉn sang tr·∫Øng ƒë·ªÉ piano ph·ªß h·∫øt */
      height:100%;
      margin:0;
      -webkit-font-smoothing:antialiased;
      font-family: Arial, Helvetica, sans-serif;
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
    }

    /* wrapper kh√¥ng gi·ªõi h·∫°n chi·ªÅu ngang n·ªØa */
    .wrap {
      width:100%;
      max-width:none;
      margin:0;
      padding:0;
      box-sizing:border-box;
      position:relative;
    }

    .sound-control{
      position: fixed;
      top:14px;
      right:14px;
      z-index:9999;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      pointer-events: auto;
    }
    .sound-toggle {
      background: linear-gradient(145deg, #2ac7ec, #1594bb);
      color:#fff;border:0;border-radius:50%;width:44px;height:44px;font-size:20px;cursor:pointer;
      display:flex;align-items:center;justify-content:center;box-shadow:0 6px 18px rgba(0,0,0,0.24);
      touch-action: manipulation;
    }
    .sound-toggle.muted{background:linear-gradient(145deg,#f44336,#d32f2f);}
    .sound-label{ color:#000;font-weight:600;font-size:13px; }

    /* piano container: chi·∫øm g·∫ßn nh∆∞ to√†n b·ªô chi·ªÅu cao khi ngang, ƒë·ªÉ piano d√≠nh ƒë√°y */
    .piano-container {
      width: 100vw;
      box-sizing: border-box;
      margin: 0;
      padding: 6px;
      background: transparent;
      overflow: hidden;
      -webkit-overflow-scrolling: touch;
      /* m·∫∑c ƒë·ªãnh kh√¥ng c·ªë ƒë·ªãnh chi·ªÅu cao; ·ªü landscape ta s·∫Ω m·ªü r·ªông */
      display: block;
    }

    .piano {
      position: relative;
      height: var(--white-key-height);
      margin: 0;
      touch-action: none;
      min-width: 320px;
      user-select: none;
      left:0;
    }

    /* Khi ·ªü landscape: m·ªü r·ªông chi·ªÅu cao ph√≠m theo viewport, d√≠nh ƒë√°y v·ªõi kho·∫£ng tr·ªëng nh·ªè */
    body.landscape {
      /* chi·ªÅu ph√≠m s·∫Ω l√† (viewport height - m·ªôt s·ªë offset) nh∆∞ng gi·ªõi h·∫°n b·∫±ng clamp ƒë·ªÉ tr√°nh qu√° l·ªõn */
      --white-key-height: clamp(140px, calc(100vh - 48px), 420px);
      --black-key-height: calc(var(--white-key-height) * 0.58);
    }
    body.landscape .piano-container {
      height: calc(100vh - var(--bottom-gap));
      display: flex;
      align-items: flex-end; /* ƒë·∫©y piano xu·ªëng ƒë√°y */
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 6px);
    }
    body.landscape .piano {
      height: var(--white-key-height);
      margin-bottom: 0;
    }

    .white-key {
      position: absolute;
      height: var(--white-key-height);
      background: var(--white-key-bg);
      border: var(--white-key-border);
      border-radius: 0 0 6px 6px;
      cursor: pointer;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding-bottom:6px;
      font-size:11px;
      color:#555;
      font-weight:700;
      box-sizing: border-box;
      transition: all 0.06s;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    .white-key.active { background: var(--active-green-w); color:#083; box-shadow: 0 6px 12px rgba(18, 88, 59, 0.18); transform: translateY(0px); }

    .black-key {
      position: absolute;
      height: var(--black-key-height);
      background: var(--black-key-bg);
      border: 1px solid #111;
      border-radius: 0 0 5px 5px;
      cursor:pointer;
      z-index: 9;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding-bottom:4px;
      font-size:10px;
      color:#fff;
      font-weight:700;
      box-shadow: 0 2px 6px rgba(0,0,0,0.5);
      transition: all 0.05s;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    .black-key.active { background: var(--active-green-b); color:#eaffea; box-shadow: 0 6px 12px rgba(20, 80, 50, 0.18); transform: translateY(0px); }

    .portrait-hint {
      text-align: center;
      color: #333;
      font-weight:700;
      margin: 10px 0 26px;
      font-size: 15px;
    }
    body.landscape .portrait-hint { display: none; }

    @media (max-width:480px){
      :root{--white-key-height:100px;--black-key-height:60px;}
      .piano-container { padding-left: 4px; padding-right: 4px; }
    }
  </style>
</head>
<body>
  <div id="appWrap" class="wrap">
    <div class="sound-control" id="soundControl">
      <button id="soundToggle" class="sound-toggle muted" aria-pressed="false" title="K√≠ch ho·∫°t √¢m">
        <span id="soundIcon">üîá</span>
      </button>
      <span id="soundStatus" class="sound-label">T·∫Øt</span>
    </div>

    <div class="piano-container" id="pianoContainer" aria-hidden="false">
      <div class="piano" id="piano" role="application" aria-label="B√†n ph√≠m piano"></div>
    </div>

    <div id="portraitHint" class="portrait-hint">‚§¥Ô∏è Xoay ngang ƒë·ªÉ hi·ªÉn th·ªã full b√†n ph√≠m</div>
  </div>

  <script>
    const pianoNotes = [
      'C3','C#3','D3','D#3','E3','F3','F#3','G3','G#3','A3','A#3','B3',
      'C4','C#4','D4','D#4','E4','F4','F#4','G4','G#4','A4','A#4','B4',
      'C5','C#5','D5','D#5','E5','F5','F#5','G5','G#5','A5'
    ];
    const notesFreq = {
      'C3':130.81,'C#3':138.59,'D3':146.83,'D#3':155.56,'E3':164.81,'F3':174.61,'F#3':185.00,
      'G3':196.00,'G#3':207.65,'A3':220.00,'A#3':233.08,'B3':246.94,
      'C4':261.63,'C#4':277.18,'D4':293.66,'D#4':311.13,'E4':329.63,'F4':349.23,'F#4':369.99,
      'G4':392.00,'G#4':415.30,'A4':440.00,'A#4':466.16,'B4':493.88,
      'C5':523.25,'C#5':554.37,'D5':587.33,'D#5':622.25,'E5':659.25,'F5':698.46,'F#5':739.99,
      'G5':783.99,'G#5':830.61,'A5':880.00
    };
    const sampleBaseURL = "https://raw.githubusercontent.com/Nhut11790/nhut11790.github.io/main/tieng/";
    const pianoFolder = "acoustic_grand_piano-mp3";

    let audioContext = null;
    let isAudioActivated = false;
    let isMuted = true;
    const sampleBuffers = {};
    const preloadState = { started: false, done: false };

    function initAudioContext(){
      if(!audioContext){
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function decodeAudioDataAsync(ctx, arrayBuffer){
      return new Promise((resolve, reject) => {
        try {
          const p = ctx.decodeAudioData(arrayBuffer, resolve, reject);
          if (p && typeof p.then === 'function'){
            p.then(resolve).catch(reject);
          }
        } catch(err){
          reject(err);
        }
      });
    }

    function convertSharpToFlat(note){
      const sharpToFlat = { 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb' };
      for (let sharp in sharpToFlat) {
        if (note.startsWith(sharp)) return note.replace(sharp, sharpToFlat[sharp]);
      }
      return note;
    }

    async function preloadPiano(concurrency = 5){
      if(preloadState.started) return;
      preloadState.started = true;
      initAudioContext();
      const notesToLoad = pianoNotes.slice();
      let idx = 0;
      const active = [];
      function next(){
        if(idx >= notesToLoad.length) return null;
        const note = notesToLoad[idx++];
        const flat = convertSharpToFlat(note);
        const fileName = flat + '.mp3';
        const url = `${sampleBaseURL}${pianoFolder}/${fileName}`;
        const p = fetch(url)
          .then(r => { if(!r.ok) throw new Error('Network'); return r.arrayBuffer(); })
          .then(buf => decodeAudioDataAsync(audioContext, buf.slice(0)))
          .then(audioBuf => { sampleBuffers[note] = audioBuf; })
          .catch(err => { /* ignore individual failures */ });
        return p;
      }
      for(let i=0;i<concurrency;i++){
        const p = (async function worker(){
          while(true){
            const job = next();
            if(!job) break;
            await job;
          }
        })();
        active.push(p);
      }
      await Promise.all(active);
      preloadState.done = true;
    }

    async function playSample(note, volume=1.0, duration=1100){
      if(!audioContext || !isAudioActivated) return;
      if(isMuted) return;
      let buffer = sampleBuffers[note];
      let rootNote = note;
      if(!buffer){
        const available = Object.keys(sampleBuffers);
        if(available.length===0){
          try{
            initAudioContext();
            const flat = convertSharpToFlat(note);
            const url = `${sampleBaseURL}${pianoFolder}/${flat}.mp3`;
            const r = await fetch(url);
            if(!r.ok) return;
            const ab = await r.arrayBuffer();
            buffer = await decodeAudioDataAsync(audioContext, ab);
            sampleBuffers[note] = buffer;
            rootNote = note;
          }catch(e){
            return;
          }
        } else {
          let best = available[0], bestDiff = Math.abs(notesFreq[best]-notesFreq[note]);
          for(const n of available){
            const d = Math.abs(notesFreq[n]-notesFreq[note]);
            if(d<bestDiff){bestDiff=d;best=n;}
          }
          buffer = sampleBuffers[best];
          rootNote = best;
        }
      }
      try{
        const src = audioContext.createBufferSource();
        src.buffer = buffer;
        const semitone = Math.log2(notesFreq[note] / notesFreq[rootNote]) * 12;
        src.playbackRate.value = Math.pow(2, semitone/12);
        const gain = audioContext.createGain();
        gain.gain.value = volume;
        src.connect(gain); gain.connect(audioContext.destination);
        src.start();
        const maxDur = Math.min(duration/1000, src.buffer.duration / Math.max(src.playbackRate.value, 0.0001));
        try{ src.stop(audioContext.currentTime + maxDur); }catch(e){}
      }catch(e){ /* ignore play errors */ }
    }

    // Render
    const pianoDiv = document.getElementById('piano');
    const pianoContainer = document.getElementById('pianoContainer');
    const appWrap = document.getElementById('appWrap');

    function getWhiteKeys(){
      const whites = [];
      pianoNotes.forEach(note=>{
        const m = note.match(/^([A-G])([#]?)(\d)$/);
        if(m && !m[2]) whites.push({note:note, key:m[1], octave:m[3]});
      });
      return whites;
    }

    function renderPiano(){
      pianoDiv.innerHTML = '';
      const whites = getWhiteKeys();
      const whiteCount = whites.length;
      const containerW = Math.max(pianoContainer.clientWidth, window.innerWidth);
      let keyWidth = Math.floor(containerW / whiteCount);
      keyWidth = Math.max(20, Math.min(keyWidth, 90));
      const pianoWidth = whiteCount * keyWidth;
      pianoDiv.style.width = pianoWidth + 'px';
      pianoDiv.style.left = '0';
      pianoDiv.style.margin = '0';

      whites.forEach((w,i)=>{
        const left = i * keyWidth;
        const key = document.createElement('div');
        key.className = 'white-key';
        key.dataset.note = w.note;
        key.textContent = w.note;
        key.style.left = left + 'px';
        key.style.width = keyWidth + 'px';
        key.id = 'key_' + w.note;
        key.setAttribute('tabindex','0');
        key.setAttribute('role','button');
        key.setAttribute('aria-pressed','false');
        bindKeyEvents(key, w.note);
        pianoDiv.appendChild(key);
      });

      const blackMap = {'C':'C#','D':'D#','F':'F#','G':'G#','A':'A#'};
      const blackWidth = Math.max( Math.floor(keyWidth * 0.62), 12 );
      whites.forEach((w,i)=>{
        const b = blackMap[w.key];
        if(!b) return;
        const blackNote = b + w.octave;
        if(!pianoNotes.includes(blackNote)) return;
        const left = Math.round(i * keyWidth + keyWidth - blackWidth/2 - (blackWidth>keyWidth?0: (blackWidth/8)));
        const k = document.createElement('div');
        k.className = 'black-key';
        k.dataset.note = blackNote;
        k.textContent = blackNote;
        k.style.left = left + 'px';
        k.style.width = blackWidth + 'px';
        k.id = 'key_' + blackNote;
        k.setAttribute('tabindex','0');
        k.setAttribute('role','button');
        k.setAttribute('aria-pressed','false');
        bindKeyEvents(k, blackNote);
        pianoDiv.appendChild(k);
      });

      if(pianoWidth > containerW){
        pianoContainer.style.overflowX = 'auto';
      } else {
        pianoContainer.style.overflowX = 'hidden';
      }
    }

    // touch/pointer
    const touchToElement = new Map();
    let globalTouchHandlersInstalled = false;

    function bindKeyEvents(el, note){
      function makeActive(element){
        if(!element) return;
        element.classList.add('active');
        element.setAttribute('aria-pressed','true');
      }
      function makeInactive(element){
        if(!element) return;
        element.classList.remove('active');
        element.setAttribute('aria-pressed','false');
      }

      const onPointerDown = (e) => {
        if (e.pointerType === 'mouse' && e.button !== 0) return;
        try{ e.preventDefault(); }catch(e){}
        if(!isAudioActivated){ flashAlertOnce(); }
        makeActive(el);
        try{ if(el.setPointerCapture) el.setPointerCapture(e.pointerId); }catch(err){}
        playSample(note, 1.0);
      };
      const onPointerUp = (e) => {
        try{ if(e && e.preventDefault) e.preventDefault(); }catch(e){}
        makeInactive(el);
        try{ if(e && e.pointerId && el.releasePointerCapture) el.releasePointerCapture(e.pointerId); }catch(err){}
      };

      const onPointerMove = (e) => {
        const pt = document.elementFromPoint(e.clientX, e.clientY);
        if(pt && pt.dataset && pt.dataset.note){
          if(pt !== el){
            makeInactive(el);
            makeActive(pt);
            playSample(pt.dataset.note, 1.0);
          }
        }
      };

      const onTouchStart = (ev) => {
        if(ev.cancelable) ev.preventDefault();
        for(const t of ev.changedTouches){
          touchToElement.set(t.identifier, el);
          makeActive(el);
          playSample(note, 1.0);
        }
      };
      const onMouseDown = (ev) => {
        if(ev.button !== 0) return;
        ev.preventDefault();
        makeActive(el);
        playSample(note, 1.0);
      };
      const onMouseUp = (ev) => {
        makeInactive(el);
      };
      const onKeyDown = (e) => {
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          if(!el.classList.contains('active')) {
            makeActive(el);
            playSample(note, 1.0);
          }
        }
      };
      const onKeyUp = (e) => {
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          makeInactive(el);
        }
      };

      if(window.PointerEvent){
        el.addEventListener('pointerdown', onPointerDown);
        el.addEventListener('pointerup', onPointerUp);
        el.addEventListener('pointercancel', onPointerUp);
        el.addEventListener('lostpointercapture', onPointerUp);
        el.addEventListener('pointermove', onPointerMove);
      } else {
        el.addEventListener('touchstart', onTouchStart, {passive:false});
        el.addEventListener('mousedown', onMouseDown);
        el.addEventListener('mouseup', onMouseUp);
        el.addEventListener('mouseleave', onMouseUp);
        if(!globalTouchHandlersInstalled){
          globalTouchHandlersInstalled = true;
          document.addEventListener('touchend', (ev) => {
            for(const t of ev.changedTouches){
              const el = touchToElement.get(t.identifier);
              if(el){
                el.classList.remove('active');
                el.setAttribute('aria-pressed','false');
                touchToElement.delete(t.identifier);
              }
            }
          }, {passive:false});
          document.addEventListener('touchcancel', (ev) => {
            for(const t of ev.changedTouches){
              const el = touchToElement.get(t.identifier);
              if(el){
                el.classList.remove('active');
                el.setAttribute('aria-pressed','false');
                touchToElement.delete(t.identifier);
              }
            }
          }, {passive:false});
          document.addEventListener('touchmove', (ev) => {
            if(ev.cancelable) ev.preventDefault();
            for(const t of ev.touches){
              const elUnder = document.elementFromPoint(t.clientX, t.clientY);
              if(elUnder && elUnder.dataset && elUnder.dataset.note){
                const prev = touchToElement.get(t.identifier);
                if(prev !== elUnder){
                  if(prev){ prev.classList.remove('active'); prev.setAttribute('aria-pressed','false'); }
                  elUnder.classList.add('active'); elUnder.setAttribute('aria-pressed','true');
                  touchToElement.set(t.identifier, elUnder);
                  playSample(elUnder.dataset.note, 1.0);
                }
              }
            }
          }, {passive:false});
        }
      }

      el.addEventListener('contextmenu', (ev) => ev.preventDefault());
      el.addEventListener('selectstart', (ev) => ev.preventDefault());
      el.addEventListener('dblclick', (e)=> e.preventDefault());
      el.addEventListener('keydown', onKeyDown);
      el.addEventListener('keyup', onKeyUp);
      if(!el.hasAttribute('tabindex')) el.setAttribute('tabindex','0');
    }

    // UI helpers
    let alertShown = false;
    function flashAlertOnce(){
      if(alertShown) return;
      alertShown = true;
      const s = document.getElementById('soundStatus');
      const orig = s.textContent;
      s.textContent = 'B·∫•m n√∫t k√≠ch √¢m ƒë·ªÉ b·∫≠t';
      s.style.color = '#FFD700';
      setTimeout(()=>{ s.textContent = orig; s.style.color=''; alertShown=false; }, 1600);
    }

    // Prevent copy/menu inside app
    document.addEventListener('contextmenu', (e) => {
      if (appWrap && appWrap.contains(e.target)) { e.preventDefault(); }
    }, {passive:false});
    document.addEventListener('selectstart', (e) => {
      if (appWrap && appWrap.contains(e.target)) { e.preventDefault(); }
    }, {passive:false});
    document.addEventListener('selectionchange', () => {
      try {
        const sel = document.getSelection();
        if (!sel) return;
        if (sel.isCollapsed) return;
        const anchor = sel.anchorNode;
        const focus = sel.focusNode;
        if ((anchor && appWrap.contains(anchor)) || (focus && appWrap.contains(focus))) {
          sel.removeAllRanges();
        }
      } catch (err) { }
    });
    document.addEventListener('copy', (e) => {
      try {
        const sel = document.getSelection();
        if ( (sel && sel.anchorNode && appWrap.contains(sel.anchorNode)) || (e.target && appWrap.contains(e.target)) ) {
          e.preventDefault();
        }
      } catch (err) {}
    }, {passive:false});

    const soundToggle = document.getElementById('soundToggle');
    const soundStatus = document.getElementById('soundStatus');

    // Activation: use synchronous resume + tiny oscillator (most reliable on iOS/WebKit)
    soundToggle.addEventListener('click', async () => {
      if(!isAudioActivated){
        soundToggle.disabled = true;
        document.getElementById('soundIcon').textContent = '‚è≥';
        soundStatus.textContent = 'ƒêang k√≠ch ho·∫°t...';
        try{
          initAudioContext();
          // Resume synchronously (inside click) and play a very short silent oscillator to unlock audio
          try {
            if (audioContext.state === 'suspended') {
              await audioContext.resume();
            }
          } catch(e){ /* ignore resume errors */ }
          try {
            const osc = audioContext.createOscillator();
            const g = audioContext.createGain();
            g.gain.value = 0.0001; // nearly silent, but ensures playback occurs
            osc.connect(g); g.connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.05); // 50ms
          } catch(e) { /* if oscillator fails, continue to fallback below */ }

          // mark activated
          isAudioActivated = true;
          isMuted = false;
          soundToggle.classList.remove('muted');
          document.getElementById('soundIcon').textContent = 'üîä';
          soundStatus.textContent = 'B·∫≠t';
          soundToggle.disabled = false;
          soundToggle.setAttribute('aria-pressed','true');

          // Start preload in background (non-blocking)
          preloadPiano(5).then(()=>{ /* done */ });

        } catch(err){
          soundToggle.disabled = false;
          document.getElementById('soundIcon').textContent = 'üîá';
          soundStatus.textContent = 'Th·ª≠ l·∫°i';
          console.warn('K√≠ch ho·∫°t audio th·∫•t b·∫°i', err);
          alert('‚ö†Ô∏è Kh√¥ng th·ªÉ k√≠ch ho·∫°t √¢m thanh.\n\nL·ªói: ' + (err && err.message ? err.message : err));
        }
        return;
      }

      // toggle mute/unmute
      isMuted = !isMuted;
      soundToggle.classList.toggle('muted', isMuted);
      document.getElementById('soundIcon').textContent = isMuted ? 'üîá' : 'üîä';
      soundStatus.textContent = isMuted ? 'T·∫Øt' : 'B·∫≠t';
      soundToggle.setAttribute('aria-pressed', String(!isMuted));
    });

    // Orientation & resize
    function applyOrientationClass(){
      const isLandscape = window.innerWidth > window.innerHeight;
      document.body.classList.toggle('landscape', isLandscape);
      const hint = document.getElementById('portraitHint');
      if(!isLandscape){
        hint.style.display = '';
        // ensure container not full-height in portrait
        pianoContainer.style.height = 'auto';
        pianoContainer.style.display = 'block';
        pianoContainer.style.paddingBottom = '6px';
      } else {
        hint.style.display = 'none';
        // handled by CSS body.landscape rules
      }
      renderPiano();
    }

    let resizeTimer = null;
    function handleResize(){
      if(resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=>{ applyOrientationClass(); resizeTimer = null; }, 120);
    }
    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleResize);

    // Prevent double-tap zoom
    (function preventDoubleTapZoom(){
      let lastTouch = 0;
      document.addEventListener('touchend', function(e){
        const t = e.target;
        if (t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable)) {
          lastTouch = Date.now();
          return;
        }
        const now = Date.now();
        if (now - lastTouch <= 300) {
          if(e.cancelable) e.preventDefault();
        }
        lastTouch = now;
      }, {passive:false});
    })();

    window.addEventListener('load', async ()=>{
      applyOrientationClass();
      try{
        initAudioContext();
        if(!/iP(hone|ad|od).*OS/.test(navigator.userAgent)){
          preloadPiano(5);
        }
      }catch(e){}
    });
  </script>
</body>
</html>
